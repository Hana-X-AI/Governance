cat > /srv/cc/Governance/x-poc3-n8n-deployment/p1-planning/PHASE-1-INTEGRATION-COMPONENTS.md << 'EOF'
# Phase 1: Claude Code Integration Components
**Quick Win Implementation - 4 Hours**

---

## Component 1: CodeRabbit Output Parser

**File**: `/srv/cc/hana-x-infrastructure/bin/parse-coderabbit.py`
```python
#!/usr/bin/env python3
"""
CodeRabbit Output Parser for Claude Code Integration

Parses CodeRabbit plain text output into structured JSON format
that Claude Code can easily consume and act upon.

Usage:
    coderabbit review --plain | parse-coderabbit.py
    
Output:
    JSON structure with issues, priorities, files, lines, and fixes
    
Author: Agent Zero
Date: 2025-11-10
Version: 1.0
"""

import sys
import json
import re
from typing import List, Dict, Optional
from dataclasses import dataclass, asdict
from enum import Enum

class Priority(str, Enum):
    """Issue priority levels"""
    P0 = "P0"  # Critical - Blocks deployment
    P1 = "P1"  # High - Should fix before merge
    P2 = "P2"  # Medium - Fix when convenient
    P3 = "P3"  # Low - Nice to have

class IssueType(str, Enum):
    """Types of issues CodeRabbit can find"""
    SECURITY = "security"
    SOLID_VIOLATION = "solid_violation"
    CODE_QUALITY = "code_quality"
    PERFORMANCE = "performance"
    DOCUMENTATION = "documentation"
    TESTING = "testing"
    STYLE = "style"
    BUG = "bug"
    OTHER = "other"

@dataclass
class Issue:
    """Structured issue from CodeRabbit"""
    id: str
    priority: Priority
    type: IssueType
    file: str
    line: Optional[int]
    message: str
    description: str
    suggested_fix: Optional[str] = None
    reference: Optional[str] = None  # Hana-X standard reference
    
    def to_dict(self):
        return asdict(self)

@dataclass
class ReviewResult:
    """Complete review result"""
    status: str
    total_issues: int
    critical_issues: int  # P0
    high_issues: int      # P1
    medium_issues: int    # P2
    low_issues: int       # P3
    issues: List[Issue]
    summary: str
    
    def to_dict(self):
        return {
            'status': self.status,
            'total_issues': self.total_issues,
            'critical_issues': self.critical_issues,
            'high_issues': self.high_issues,
            'medium_issues': self.medium_issues,
            'low_issues': self.low_issues,
            'issues': [issue.to_dict() for issue in self.issues],
            'summary': self.summary
        }

class CodeRabbitParser:
    """Parser for CodeRabbit output"""
    
    # Pattern definitions
    PATTERNS = {
        'file_line': re.compile(r'(?:File:\s*)?(\S+\.(?:py|ts|tsx|js|jsx|yaml|yml|json)):(\d+)'),
        'error': re.compile(r'(?:Error|Critical|âŒ|ðŸ”´)[:|\s](.+)', re.IGNORECASE),
        'warning': re.compile(r'(?:Warning|High|âš ï¸|ðŸŸ¡)[:|\s](.+)', re.IGNORECASE),
        'info': re.compile(r'(?:Info|Medium|â„¹ï¸|âš«)[:|\s](.+)', re.IGNORECASE),
        'suggestion': re.compile(r'(?:Suggestion|Low|ðŸ’¡|âšª)[:|\s](.+)', re.IGNORECASE),
        'hardcoded_secret': re.compile(r'(?:hardcoded|secret|api[_\s]?key|password|token)', re.IGNORECASE),
        'solid_srp': re.compile(r'(?:single responsibility|multiple responsibilities|mixed concerns)', re.IGNORECASE),
        'solid_ocp': re.compile(r'(?:open.closed|modification|extension|instanceof)', re.IGNORECASE),
        'solid_lsp': re.compile(r'(?:liskov|substitution|contract|precondition|postcondition)', re.IGNORECASE),
        'solid_isp': re.compile(r'(?:interface segregation|fat interface|unused method)', re.IGNORECASE),
        'solid_dip': re.compile(r'(?:dependency inversion|concrete class|dependency injection)', re.IGNORECASE),
        'missing_types': re.compile(r'(?:type hint|type annotation|missing type)', re.IGNORECASE),
        'missing_docs': re.compile(r'(?:docstring|documentation|missing doc|undocumented)', re.IGNORECASE),
        'complexity': re.compile(r'(?:complexity|too complex|simplify)', re.IGNORECASE),
        'test_coverage': re.compile(r'(?:test|coverage|untested)', re.IGNORECASE),
    }
    
    def __init__(self):
        self.issue_counter = 0
        
    def parse(self, text: str) -> ReviewResult:
        """Parse CodeRabbit output text"""
        issues = []
        lines = text.split('\n')
        
        current_issue = None
        current_context = []
        
        for line_num, line in enumerate(lines):
            line = line.strip()
            if not line:
                if current_issue and current_context:
                    current_issue.description = ' '.join(current_context)
                    current_context = []
                continue
            
            # Try to detect issue start
            priority = self._detect_priority(line)
            if priority:
                # Save previous issue
                if current_issue:
                    if current_context:
                        current_issue.description = ' '.join(current_context)
                    issues.append(current_issue)
                
                # Start new issue
                self.issue_counter += 1
                current_issue = Issue(
                    id=f"DEF-{self.issue_counter:03d}",
                    priority=priority,
                    type=self._detect_type(line),
                    file="unknown",
                    line=None,
                    message=self._extract_message(line),
                    description=""
                )
                current_context = []
            
            # Extract file and line info
            file_match = self.PATTERNS['file_line'].search(line)
            if file_match and current_issue:
                current_issue.file = file_match.group(1)
                current_issue.line = int(file_match.group(2))
            
            # Accumulate context
            if current_issue and line:
                current_context.append(line)
            
            # Generate suggested fix
            if current_issue and not current_issue.suggested_fix:
                current_issue.suggested_fix = self._generate_fix(current_issue)
            
            # Add Hana-X standard reference
            if current_issue and not current_issue.reference:
                current_issue.reference = self._get_standard_reference(current_issue)
        
        # Save last issue
        if current_issue:
            if current_context:
                current_issue.description = ' '.join(current_context)
            issues.append(current_issue)
        
        # Count by priority
        critical = len([i for i in issues if i.priority == Priority.P0])
        high = len([i for i in issues if i.priority == Priority.P1])
        medium = len([i for i in issues if i.priority == Priority.P2])
        low = len([i for i in issues if i.priority == Priority.P3])
        
        # Generate summary
        summary = self._generate_summary(len(issues), critical, high, medium, low)
        
        return ReviewResult(
            status="completed",
            total_issues=len(issues),
            critical_issues=critical,
            high_issues=high,
            medium_issues=medium,
            low_issues=low,
            issues=issues,
            summary=summary
        )
    
    def _detect_priority(self, line: str) -> Optional[Priority]:
        """Detect issue priority from line"""
        if self.PATTERNS['error'].search(line):
            return Priority.P0
        elif self.PATTERNS['warning'].search(line):
            return Priority.P1
        elif self.PATTERNS['info'].search(line):
            return Priority.P2
        elif self.PATTERNS['suggestion'].search(line):
            return Priority.P3
        return None
    
    def _detect_type(self, text: str) -> IssueType:
        """Detect issue type from content"""
        if self.PATTERNS['hardcoded_secret'].search(text):
            return IssueType.SECURITY
        elif any(self.PATTERNS[p].search(text) for p in ['solid_srp', 'solid_ocp', 'solid_lsp', 'solid_isp', 'solid_dip']):
            return IssueType.SOLID_VIOLATION
        elif self.PATTERNS['missing_types'].search(text):
            return IssueType.CODE_QUALITY
        elif self.PATTERNS['missing_docs'].search(text):
            return IssueType.DOCUMENTATION
        elif self.PATTERNS['complexity'].search(text):
            return IssueType.PERFORMANCE
        elif self.PATTERNS['test_coverage'].search(text):
            return IssueType.TESTING
        else:
            return IssueType.OTHER
    
    def _extract_message(self, line: str) -> str:
        """Extract clean message from line"""
        # Remove priority indicators
        for pattern in [self.PATTERNS['error'], self.PATTERNS['warning'], 
                       self.PATTERNS['info'], self.PATTERNS['suggestion']]:
            match = pattern.search(line)
            if match:
                return match.group(1).strip()
        return line.strip()
    
    def _generate_fix(self, issue: Issue) -> str:
        """Generate suggested fix based on issue type"""
        fixes = {
            IssueType.SECURITY: "Move sensitive data to environment variables. Use .env file and load with os.getenv().",
            IssueType.SOLID_VIOLATION: "Refactor to follow SOLID principles. See Hana-X Development Standards Section 2.",
            IssueType.CODE_QUALITY: "Add type hints to all function parameters and return types.",
            IssueType.DOCUMENTATION: "Add docstring with description, parameters, returns, and example.",
            IssueType.TESTING: "Add unit tests with pytest. Target 80%+ coverage.",
            IssueType.PERFORMANCE: "Simplify function by extracting sub-functions. Keep complexity < 10.",
            IssueType.STYLE: "Run black and pylint to fix style issues automatically.",
        }
        return fixes.get(issue.type, "Review and fix according to Hana-X standards.")
    
    def _get_standard_reference(self, issue: Issue) -> str:
        """Get Hana-X standard reference for issue"""
        references = {
            IssueType.SECURITY: "Hana-X Standards: Section 4.2 - Security",
            IssueType.SOLID_VIOLATION: "Hana-X Standards: Section 2 - SOLID Principles",
            IssueType.CODE_QUALITY: "Hana-X Standards: Section 6.1 - Python Standards",
            IssueType.DOCUMENTATION: "Hana-X Standards: Section 3.1 - Documentation",
            IssueType.TESTING: "Hana-X Standards: Section 5 - Testing",
        }
        return references.get(issue.type, "Hana-X Development and Coding Standards")
    
    def _generate_summary(self, total: int, critical: int, high: int, medium: int, low: int) -> str:
        """Generate human-readable summary"""
        if total == 0:
            return "âœ… No issues found. Code meets Hana-X standards."
        
        parts = [f"Found {total} issue{'s' if total != 1 else ''}:"]
        if critical > 0:
            parts.append(f"ðŸ”´ {critical} critical (P0)")
        if high > 0:
            parts.append(f"ðŸŸ¡ {high} high (P1)")
        if medium > 0:
            parts.append(f"âš« {medium} medium (P2)")
        if low > 0:
            parts.append(f"âšª {low} low (P3)")
        
        if critical > 0:
            parts.append("âš ï¸  Critical issues must be fixed before deployment.")
        
        return " | ".join(parts)

def main():
    """Main entry point"""
    try:
        # Read from stdin
        text = sys.stdin.read()
        
        # Parse
        parser = CodeRabbitParser()
        result = parser.parse(text)
        
        # Output JSON
        print(json.dumps(result.to_dict(), indent=2))
        
        # Exit with error code if critical issues found
        sys.exit(1 if result.critical_issues > 0 else 0)
        
    except Exception as e:
        error_result = {
            'status': 'error',
            'error': str(e),
            'message': 'Failed to parse CodeRabbit output'
        }
        print(json.dumps(error_result, indent=2), file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
```

---

## Component 2: Wrapper Script

**File**: `/srv/cc/hana-x-infrastructure/bin/coderabbit-json`
```bash
#!/bin/bash
#
# coderabbit-json - CodeRabbit with JSON output for Claude Code
#
# Usage:
#   coderabbit-json [OPTIONS]
#
# Options:
#   --mode <mode>        Review mode: security, quality, all (default: all)
#   --path <path>        Path to review (default: current directory)
#   --save-log          Save output to DEFECT-LOG.md
#   --help              Show this help
#
# Output:
#   Structured JSON to stdout
#   Exit code 0 if no critical issues, 1 if critical issues found
#
# Examples:
#   coderabbit-json
#   coderabbit-json --mode security
#   coderabbit-json --path src/backend --save-log
#
# Author: Agent Zero
# Date: 2025-11-10
# Version: 1.0

set -euo pipefail

# Default values
MODE="all"
PATH_TO_REVIEW="."
SAVE_LOG=false
PARSER="/srv/cc/hana-x-infrastructure/bin/parse-coderabbit.py"

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Help function
show_help() {
    sed -n '2,/^$/p' "$0" | sed 's/^# \?//'
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --mode)
            MODE="$2"
            shift 2
            ;;
        --path)
            PATH_TO_REVIEW="$2"
            shift 2
            ;;
        --save-log)
            SAVE_LOG=true
            shift
            ;;
        --help|-h)
            show_help
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run with --help for usage"
            exit 1
            ;;
    esac
done

# Check if CodeRabbit is installed
if ! command -v coderabbit &> /dev/null; then
    echo -e "${RED}Error: CodeRabbit CLI not found${NC}" >&2
    echo "Install with: curl -fsSL https://cli.coderabbit.ai/install.sh | sh" >&2
    exit 1
fi

# Check if parser exists
if [ ! -f "$PARSER" ]; then
    echo -e "${RED}Error: Parser not found at $PARSER${NC}" >&2
    exit 1
fi

# Temp file for CodeRabbit output
TEMP_OUTPUT=$(mktemp)
trap "rm -f $TEMP_OUTPUT" EXIT

# Build CodeRabbit command
CODERABBIT_CMD="coderabbit review --plain"

case $MODE in
    security)
        CODERABBIT_CMD="$CODERABBIT_CMD --checks security"
        ;;
    quality)
        CODERABBIT_CMD="$CODERABBIT_CMD --checks quality"
        ;;
    all)
        # Default - no additional flags
        ;;
    *)
        echo -e "${RED}Error: Invalid mode '$MODE'${NC}" >&2
        echo "Valid modes: security, quality, all" >&2
        exit 1
        ;;
esac

# Add path if not current directory
if [ "$PATH_TO_REVIEW" != "." ]; then
    CODERABBIT_CMD="$CODERABBIT_CMD $PATH_TO_REVIEW"
fi

# Run CodeRabbit
echo -e "${BLUE}ðŸ° Running CodeRabbit review (mode: $MODE)...${NC}" >&2

if $CODERABBIT_CMD > "$TEMP_OUTPUT" 2>&1; then
    CODERABBIT_EXIT=0
else
    CODERABBIT_EXIT=$?
fi

# Parse output to JSON
echo -e "${BLUE}ðŸ“Š Parsing results...${NC}" >&2

if JSON_OUTPUT=$(python3 "$PARSER" < "$TEMP_OUTPUT"); then
    PARSER_EXIT=0
else
    PARSER_EXIT=$?
fi

# Output JSON to stdout
echo "$JSON_OUTPUT"

# Save to DEFECT-LOG.md if requested
if $SAVE_LOG; then
    DEFECT_LOG="DEFECT-LOG.md"
    
    if [ ! -f "$DEFECT_LOG" ]; then
        cat > "$DEFECT_LOG" << 'DEFECTLOG'
# Defect Log

**Project**: $(basename "$(pwd)")  
**Created**: $(date +%Y-%m-%d)

---

## Active Defects

DEFECTLOG
    fi
    
    # Append issues to defect log
    echo "" >> "$DEFECT_LOG"
    echo "## Review - $(date '+%Y-%m-%d %H:%M:%S')" >> "$DEFECT_LOG"
    echo "" >> "$DEFECT_LOG"
    
    # Extract issues from JSON and format for markdown
    echo "$JSON_OUTPUT" | python3 -c "
import sys
import json

data = json.load(sys.stdin)
for issue in data.get('issues', []):
    print(f\"### {issue['id']}\")
    print(f\"**Priority**: {issue['priority']}\")
    print(f\"**Type**: {issue['type']}\")
    print(f\"**File**: {issue['file']}:{issue.get('line', 'N/A')}\")
    print(f\"**Message**: {issue['message']}\")
    print(f\"**Fix**: {issue.get('suggested_fix', 'N/A')}\")
    print()
" >> "$DEFECT_LOG"
    
    echo -e "${GREEN}ðŸ“ Saved to $DEFECT_LOG${NC}" >&2
fi

# Summary to stderr
TOTAL=$(echo "$JSON_OUTPUT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('total_issues', 0))")
CRITICAL=$(echo "$JSON_OUTPUT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('critical_issues', 0))")

echo "" >&2
if [ "$TOTAL" -eq 0 ]; then
    echo -e "${GREEN}âœ… No issues found. Code meets standards.${NC}" >&2
    exit 0
else
    if [ "$CRITICAL" -gt 0 ]; then
        echo -e "${RED}âŒ Found $TOTAL issues ($CRITICAL critical). Fix P0 issues before deployment.${NC}" >&2
        exit 1
    else
        echo -e "${YELLOW}âš ï¸  Found $TOTAL issues (no critical). Review and fix when convenient.${NC}" >&2
        exit 0
    fi
fi
```

---

## Component 3: Claude Code Guidance

**File**: `/srv/cc/Governance/x-poc3-n8n-deployment/config/CLAUDE-CODE-CODERABBIT-GUIDE.md`
```markdown
# Claude Code + CodeRabbit Integration Guide
**For: Hana-X Development Team**  
**Version**: 1.0  
**Date**: 2025-11-10

---

## Overview

This guide shows how to use CodeRabbit reviews within Claude Code for automated code quality checks and fixes.

**Key Benefit**: Natural language code review and auto-fix workflow, just like the demo video.

---

## Quick Start

### Basic Workflow

When working in Claude Code:
```
1. You: "Implement [feature]"
2. Claude: [writes code]
3. You: "Run CodeRabbit"
4. Claude: [runs review, shows results]
5. You: "Fix all critical issues"
6. Claude: [makes fixes automatically]
7. You: "Verify with CodeRabbit"
8. Claude: [confirms clean]