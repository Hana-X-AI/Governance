# CodeRabbit Exit Codes Standard
**Exit Code Reference and CI/CD Integration**

**Document Type**: Architecture - Exit Code Standard
**Created**: 2025-11-10
**Version**: 1.0
**Status**: Production Standard

---

## Overview

This document defines the exit code standard for `coderabbit-json` and provides guidance for CI/CD pipeline integration.

**Purpose**: Enable automated decision-making based on code review results

**Key Principle**: Exit codes follow Unix conventions (0 = success, non-zero = failure)

---

## Exit Code Definitions

### Exit Code 0: Success

**Meaning**: Review completed successfully with NO critical issues

**Scenarios**:
- No issues found at all
- Only low-priority issues (P2, P3) found
- All high-priority issues have been fixed

**Example Output**:
```bash
$ coderabbit-json
{
  "status": "completed",
  "total_issues": 2,
  "critical_issues": 0,
  "high_issues": 0,
  "medium_issues": 2,
  "low_issues": 0,
  ...
}

$ echo $?
0
```

**CI/CD Behavior**: ✅ Allow pipeline to continue

---

### Exit Code 1: Failure

**Meaning**: Critical issues found OR error occurred

**Scenarios**:

#### Scenario A: Critical Issues (P0)
```bash
$ coderabbit-json
{
  "status": "completed",
  "total_issues": 3,
  "critical_issues": 1,  # ← Blocks deployment
  ...
}

$ echo $?
1
```

**Reason**: P0 issues MUST be fixed before deployment

---

#### Scenario B: Parser Error
```bash
$ coderabbit-json
{
  "status": "error",
  "error": "Failed to parse CodeRabbit output",
  "message": "Unexpected output format"
}

$ echo $?
1
```

**Reason**: Review could not complete successfully

---

#### Scenario C: CodeRabbit CLI Not Found
```bash
$ coderabbit-json
Error: CodeRabbit CLI not found
Install with: curl -fsSL https://cli.coderabbit.ai/install.sh | sh

$ echo $?
1
```

**Reason**: Infrastructure not properly configured

---

## Exit Code Logic

### Decision Tree

```
coderabbit-json execution
  ↓
CodeRabbit CLI available?
  ├─ NO → Exit 1 (CLI not found)
  └─ YES → Continue
       ↓
CodeRabbit runs successfully?
  ├─ NO → Exit 1 (CodeRabbit error)
  └─ YES → Continue
       ↓
Parser processes output?
  ├─ NO → Exit 1 (Parser error)
  └─ YES → Continue
       ↓
Critical issues (P0) found?
  ├─ YES → Exit 1 (Blocks deployment)
  └─ NO → Exit 0 (Success)
```

### Implementation

**In `parse-coderabbit.py`**:
```python
def main():
    try:
        text = sys.stdin.read()
        parser = CodeRabbitParser()
        result = parser.parse(text)

        print(json.dumps(result.to_dict(), indent=2))

        # Exit with error code if critical issues found
        sys.exit(1 if result.critical_issues > 0 else 0)

    except Exception as e:
        error_result = {
            'status': 'error',
            'error': str(e),
            'message': 'Failed to parse CodeRabbit output'
        }
        print(json.dumps(error_result, indent=2), file=sys.stderr)
        sys.exit(1)
```

**In `coderabbit-json` wrapper**:
```bash
# Run CodeRabbit and parse
JSON_OUTPUT=$(python3 "$PARSER" < "$TEMP_OUTPUT")
CRITICAL=$(echo "$JSON_OUTPUT" | python3 -c "import sys, json; print(json.load(sys.stdin).get('critical_issues', 0))")

# Exit based on critical issues
if [ "$CRITICAL" -gt 0 ]; then
    echo "❌ Found critical issues. Fix P0 issues before deployment." >&2
    exit 1
else
    echo "✅ No critical issues found." >&2
    exit 0
fi
```

---

## CI/CD Pipeline Integration

### GitHub Actions Example

```yaml
name: Code Quality Check

on: [push, pull_request]

jobs:
  coderabbit-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run CodeRabbit Review
        id: review
        run: |
          coderabbit-json --save-log
        continue-on-error: true  # Capture exit code

      - name: Check Results
        if: steps.review.outcome == 'failure'
        run: |
          echo "❌ Critical issues found. See DEFECT-LOG.md"
          cat DEFECT-LOG.md
          exit 1  # Block deployment

      - name: Success
        if: steps.review.outcome == 'success'
        run: |
          echo "✅ Code quality check passed"
```

---

### GitLab CI Example

```yaml
code_quality:
  stage: test
  script:
    - coderabbit-json --save-log
  artifacts:
    when: always
    paths:
      - DEFECT-LOG.md
  allow_failure: false  # Block pipeline on exit code 1
```

---

### Jenkins Pipeline Example

```groovy
pipeline {
    agent any

    stages {
        stage('Code Quality') {
            steps {
                script {
                    def exitCode = sh(
                        script: 'coderabbit-json --save-log',
                        returnStatus: true
                    )

                    if (exitCode != 0) {
                        error("Critical issues found. See DEFECT-LOG.md")
                    }
                }
            }
        }
    }

    post {
        always {
            archiveArtifacts artifacts: 'DEFECT-LOG.md', allowEmptyArchive: true
        }
    }
}
```

---

## Shell Script Integration

### Pre-Commit Hook Example

```bash
#!/bin/bash
# .git/hooks/pre-commit

echo "Running CodeRabbit review..."

if ! coderabbit-json; then
    echo ""
    echo "❌ COMMIT BLOCKED: Critical issues found"
    echo "Fix P0 issues or use --no-verify to bypass"
    exit 1
fi

echo "✅ Code quality check passed"
exit 0
```

**Usage**:
```bash
# Normal commit (runs check)
git commit -m "Add feature"

# Bypass check (use with caution!)
git commit --no-verify -m "Emergency hotfix"
```

---

### Pre-Push Hook Example

```bash
#!/bin/bash
# .git/hooks/pre-push

echo "Running final CodeRabbit review before push..."

if ! coderabbit-json --save-log; then
    echo ""
    echo "❌ PUSH BLOCKED: Critical issues detected"
    echo "Review DEFECT-LOG.md and fix P0 issues"
    echo ""
    echo "To bypass: git push --no-verify"
    exit 1
fi

echo "✅ Safe to push"
exit 0
```

---

## Deployment Gate Example

### Kubernetes Deployment Gate

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pre-deploy-check
spec:
  containers:
  - name: quality-gate
    image: coderabbit-cli
    command:
      - /bin/sh
      - -c
      - |
        cd /app
        if ! coderabbit-json --save-log; then
          echo "❌ Deployment blocked: Critical issues"
          exit 1
        fi
        echo "✅ Quality gate passed"
  restartPolicy: Never
```

---

## Testing Exit Codes

### Manual Testing

```bash
# Test success (no issues)
cd /path/to/clean/code
coderabbit-json
echo "Exit code: $?"  # Should be 0

# Test failure (with issues)
cd /path/to/code/with/issues
coderabbit-json
echo "Exit code: $?"  # Should be 1

# Test error handling (no CLI)
mv /usr/local/bin/coderabbit /tmp/
coderabbit-json
echo "Exit code: $?"  # Should be 1
mv /tmp/coderabbit /usr/local/bin/
```

### Automated Testing

```bash
#!/bin/bash
# test-exit-codes.sh

set -e

echo "Testing exit code 0 (success)..."
cd test-fixtures/clean-code
if coderabbit-json >/dev/null 2>&1; then
    echo "✅ Exit code 0 test passed"
else
    echo "❌ Expected exit code 0, got $?"
    exit 1
fi

echo "Testing exit code 1 (critical issues)..."
cd ../code-with-p0-issues
if ! coderabbit-json >/dev/null 2>&1; then
    echo "✅ Exit code 1 test passed"
else
    echo "❌ Expected exit code 1, got 0"
    exit 1
fi

echo "All exit code tests passed!"
```

---

## Error Handling Patterns

### Pattern 1: Fail Fast

```bash
#!/bin/bash
set -e  # Exit immediately on any error

coderabbit-json
# If exit code is 1, script stops here

echo "Deploying..."
# Only runs if exit code was 0
```

### Pattern 2: Conditional Deployment

```bash
#!/bin/bash

if coderabbit-json; then
    echo "✅ Quality check passed - deploying"
    ./deploy.sh
else
    echo "❌ Quality check failed - NOT deploying"
    echo "Review DEFECT-LOG.md for issues"
    exit 1
fi
```

### Pattern 3: Warning Mode

```bash
#!/bin/bash

if ! coderabbit-json; then
    echo "⚠️  WARNING: Quality issues found"
    echo "Deploying anyway (warning mode)"
    # Continue with deployment despite issues
else
    echo "✅ Clean deployment"
fi

./deploy.sh
```

---

## Exit Code Best Practices

### 1. Always Check Exit Codes

✅ **Do**:
```bash
if coderabbit-json; then
    echo "Success"
else
    echo "Failure: $?"
fi
```

❌ **Don't**:
```bash
coderabbit-json  # Ignores exit code
echo "Continuing..."
```

### 2. Use `set -e` for Safety

✅ **Do**:
```bash
#!/bin/bash
set -e  # Fail fast on any error

coderabbit-json
deploy.sh
```

❌ **Don't**:
```bash
#!/bin/bash
# No set -e - errors ignored!

coderabbit-json
deploy.sh  # Runs even if review failed
```

### 3. Provide Clear Error Messages

✅ **Do**:
```bash
if ! coderabbit-json; then
    echo "❌ DEPLOYMENT BLOCKED"
    echo "Reason: Critical code quality issues found"
    echo "Action: Review DEFECT-LOG.md and fix P0 issues"
    exit 1
fi
```

❌ **Don't**:
```bash
coderabbit-json || exit 1  # No context for failure
```

### 4. Capture Output for Debugging

✅ **Do**:
```bash
OUTPUT=$(coderabbit-json 2>&1)
EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
    echo "Review failed:"
    echo "$OUTPUT"
    exit 1
fi
```

---

## Summary Table

| Exit Code | Meaning | CI/CD Action | User Action |
|-----------|---------|--------------|-------------|
| **0** | Success, no P0 issues | ✅ Continue pipeline | Proceed with commit/deploy |
| **1** | P0 issues found | ❌ Block pipeline | Fix critical issues |
| **1** | Parser error | ❌ Block pipeline | Check logs, report bug |
| **1** | CLI not found | ❌ Block pipeline | Install CodeRabbit CLI |

---

## Quick Reference

```bash
# Check exit code
coderabbit-json
echo $?

# Use in if statement
if coderabbit-json; then
    echo "Success"
else
    echo "Failure: $?"
fi

# Capture exit code
coderabbit-json
EXIT_CODE=$?
echo "Got: $EXIT_CODE"

# Pre-commit hook pattern
coderabbit-json || exit 1

# CI/CD pattern
coderabbit-json --save-log
test $? -eq 0 || exit 1
```

---

**Document Version**: 1.0
**Classification**: Internal - Standard
**Status**: Production
**Next Review**: After Phase 1 deployment

---

*Automation = Reliable exit codes > Manual checks*
*CI/CD = Fail fast on P0 > Deploy with issues*
