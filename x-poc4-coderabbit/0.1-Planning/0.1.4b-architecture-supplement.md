cat > /srv/cc/Governance/x-poc3-n8n-deployment/p1-planning/INTEGRATION-ARCHITECTURE.md << 'EOF'
# Claude Code Integration Architecture
**Critical Update**: Bridging the Gap

---

## Problem Identified

**Current Design**: Roger as standalone CLI tool  
**Video Demo**: CodeRabbit integrated into Claude Code workflow  
**Gap**: Missing seamless integration layer

---

## Required Architecture Updates

### Current (Incomplete):
````
Claude Code
    ↓ (separate process)
Terminal → roger review
    ↓
CodeRabbit
    ↓
DEFECT-LOG.md
    ↓
User reads and tells Claude to fix
````

### Required (Complete):
````
Claude Code
    ↓ (direct call via MCP or bash)
Roger (MCP Server or callable script)
    ↓
CodeRabbit
    ↓
Structured JSON output
    ↓
Claude Code reads results
    ↓
Claude Code auto-fixes
    ↓
Roger verifies
    ↓
✅ Done
````

---

## Three Integration Options

### Option 1: MCP Server (Best - Long Term)
**What**: Build Roger as MCP (Model Context Protocol) server  
**How**: Claude Code can call MCP servers natively  
**Benefit**: Seamless integration, structured data exchange  
**Effort**: 3-5 days to build MCP server  
````python
# Roger as MCP Server
@mcp_tool
def review_code(path: str, auto_fix: bool = False):
    """Run CodeRabbit review and return structured results"""
    results = run_coderabbit(path)
    return {
        "issues": parse_issues(results),
        "fixes": auto_fix_issues(results) if auto_fix else None
    }
````

**Claude Code Usage**:
````
User: "Run CodeRabbit"
Claude: [Calls Roger MCP tool internally]
Claude: "Found 3 issues: [lists them]"
User: "Fix them"
Claude: [Reads issue data, makes fixes]
````

### Option 2: Enhanced Bash Integration (Good - Medium Term)
**What**: Make Roger output JSON that Claude Code can parse  
**How**: Claude Code can run bash commands and read output  
**Benefit**: Works with current setup, quick to implement  
**Effort**: 1-2 days to enhance Roger output  
````bash
# Enhanced Roger
roger review --format=json --output=stdout

# Returns:
{
  "status": "completed",
  "issues": [
    {
      "id": "DEF-001",
      "priority": "P0",
      "file": "src/file.py",
      "line": 42,
      "message": "Hardcoded API key",
      "fix": "Move to environment variable"
    }
  ]
}
````

**Claude Code Usage**:
````
User: "Run CodeRabbit"
Claude: [Runs: roger review --format=json]
Claude: [Parses JSON output]
Claude: "Found 3 issues: [lists them]"
User: "Fix them"
Claude: [Uses parsed data to make targeted fixes]
````

### Option 3: Direct CodeRabbit + Custom Parser (Quick - Short Term)
**What**: Claude Code calls CodeRabbit directly, we provide parser  
**How**: Wrapper script that formats CodeRabbit output  
**Benefit**: Can implement today  
**Effort**: 2-4 hours  
````bash
# Wrapper script: coderabbit-json
#!/bin/bash
coderabbit review --plain | python3 /srv/cc/hana-x-infrastructure/bin/parse-coderabbit.py
````

**Claude Code Usage**:
````
User: "Run CodeRabbit"
Claude: [Runs: coderabbit-json]
Claude: [Parses JSON output]
Claude: "Found issues, fixing..."
````

---

## Recommended Implementation Path

### Phase 1: Quick Win (Today - Option 3)
**Goal**: Get basic workflow working  
**Time**: 4 hours  

1. Create CodeRabbit output parser
2. Wrapper script for JSON output
3. Test with Claude Code
4. Document usage pattern

**Result**: Claude can run CodeRabbit and parse results

### Phase 2: Enhanced Integration (Week 2 - Option 2)
**Goal**: Full Roger integration  
**Time**: 2 days  

1. Enhance Roger with JSON output
2. Add structured issue data
3. Add suggested fixes in output
4. Test auto-fix workflow

**Result**: Full workflow like video demo

### Phase 3: Native Integration (Month 2 - Option 1)
**Goal**: Production-grade MCP server  
**Time**: 5 days  

1. Build Roger MCP server
2. Register with Claude Code
3. Native tool calling
4. Advanced features (background tasks, webhooks)

**Result**: Seamless, production-ready integration

---

## Updated Architecture
````mermaid
graph TB
    subgraph "Claude Code"
        A[User: Run CodeRabbit]
        B[Claude Code Engine]
        C[Bash Tool]
    end
    
    subgraph "Integration Layer - NEW"
        D[coderabbit-json wrapper]
        E[Parser Script]
        F[Structured JSON]
    end
    
    subgraph "Existing Infrastructure"
        G[CodeRabbit CLI]
        H[Roger Agent]
        I[DEFECT-LOG.md]
    end
    
    A --> B
    B --> C
    C --> D
    D --> G
    G --> E
    E --> F
    F --> B
    B --> H
    H --> I
    
    style D fill:#FFD700
    style E fill:#FFD700
    style F fill:#FFD700
````

---

## Implementation: Phase 1 (Quick Win)

### Step 1: Create CodeRabbit Parser
````python
#!/usr/bin/env python3
# /srv/cc/hana-x-infrastructure/bin/parse-coderabbit.py
"""
Parse CodeRabbit plain text output to structured JSON
for Claude Code consumption
"""

import sys
import json
import re
from typing import List, Dict

def parse_coderabbit_output(text: str) -> Dict:
    """Parse CodeRabbit plain text to structured format"""
    
    issues = []
    current_issue = None
    
    # Simple pattern matching (enhance as needed)
    lines = text.split('\n')
    
    for line in lines:
        # Detect issue severity
        if 'Error:' in line or 'Critical:' in line:
            if current_issue:
                issues.append(current_issue)
            current_issue = {
                'priority': 'P0',
                'type': 'error',
                'message': line.strip()
            }
        elif 'Warning:' in line:
            if current_issue:
                issues.append(current_issue)
            current_issue = {
                'priority': 'P1',
                'type': 'warning',
                'message': line.strip()
            }
        
        # Extract file and line info
        file_match = re.search(r'(\S+\.py):(\d+)', line)
        if file_match and current_issue:
            current_issue['file'] = file_match.group(1)
            current_issue['line'] = int(file_match.group(2))
    
    if current_issue:
        issues.append(current_issue)
    
    return {
        'status': 'completed',
        'total_issues': len(issues),
        'critical_issues': len([i for i in issues if i['priority'] == 'P0']),
        'issues': issues
    }

def main():
    # Read from stdin
    text = sys.stdin.read()
    
    # Parse
    result = parse_coderabbit_output(text)
    
    # Output JSON
    print(json.dumps(result, indent=2))

if __name__ == '__main__':
    main()
````

### Step 2: Create Wrapper Script
````bash
#!/bin/bash
# /srv/cc/hana-x-infrastructure/bin/coderabbit-json

set -e

# Run CodeRabbit and parse output
coderabbit review --plain 2>&1 | python3 /srv/cc/hana-x-infrastructure/bin/parse-coderabbit.py

# Also save to defect log
# (Roger can process this later)
````

### Step 3: Make Available to Claude Code
````bash
# Install globally
sudo chmod +x /srv/cc/hana-x-infrastructure/bin/parse-coderabbit.py
sudo chmod +x /srv/cc/hana-x-infrastructure/bin/coderabbit-json
sudo ln -sf /srv/cc/hana-x-infrastructure/bin/coderabbit-json /usr/local/bin/coderabbit-json
````

### Step 4: Test with Claude Code
````bash
# In Claude Code, test:
cd /srv/cc/Governance/x-poc3-n8n-deployment

# Run wrapper
coderabbit-json

# Should output structured JSON
````

### Step 5: Update Claude Code Instructions
````markdown
# Add to config/claude.md

## Running Code Reviews

To review code with CodeRabbit:
```bash
# Get structured output
coderabbit-json
```

This returns JSON with:
- List of issues
- Priority levels
- File locations
- Line numbers
- Suggested fixes

You can then parse this and make targeted fixes.
````

---

## Testing the Workflow

### Test Case 1: Basic Review
````
User: "Run coderabbit-json and show me what issues exist"

Claude: [Runs command]
        [Parses JSON]
        "Found 3 issues:
         1. P0: Hardcoded API key in src/auth.py:42
         2. P1: Missing type hints in src/utils.py:15
         3. P2: Function too complex in src/process.py:89"

User: "Fix the P0 issue"

Claude: [Uses JSON data to locate exact issue]
        [Makes targeted fix]
        "Fixed: Moved API key to environment variable"
````

### Test Case 2: Auto-Fix
````
User: "Run coderabbit-json and fix all P0 and P1 issues"

Claude: [Runs command]
        [Parses JSON]
        [Iterates through P0/P1 issues]
        [Makes fixes for each]
        [Re-runs coderabbit-json to verify]
        "Fixed 5 issues:
         ✅ Moved API key to .env
         ✅ Added type hints to 3 functions
         ✅ Added error handling
         ✅ Improved validation
         ✅ Updated documentation"
````

---

## Answer to Your Question

**Does our solution allow for this workflow?**

**Current State**: ❌ Not fully - missing integration layer  

**With Phase 1 Updates**: ✅ YES - basic workflow works  
- Run: `coderabbit-json`
- Claude parses JSON
- Claude fixes issues
- Time: 4 hours to implement

**With Phase 2 Updates**: ✅✅ YES - full workflow like video  
- Natural language: "Run CodeRabbit"
- Roger handles everything
- Claude auto-fixes
- Time: 2 days to implement

**With Phase 3 Updates**: ✅✅✅ YES - production-grade native integration  
- MCP server integration
- Seamless tool calling
- Background processing
- Time: 5 days to implement

---

## Recommendation

**Implement Phase 1 today (4 hours)** to get basic workflow working, then decide if Phase 2/3 needed based on actual usage.

**Next Step**: Create the parser and wrapper scripts?

EOF